\documentclass[11pt, oneside]{article}  	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage[margin=2.25cm]{geometry}        		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}          		% ... or a4paper or a5paper or ... 
%\geometry{landscape}        		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}  		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex	
								
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{babel}
%\usepackage{csquotes}
									
\usepackage{amssymb}
\usepackage{lineno}
\linenumbers
\usepackage{setspace}
%\doublespacing
\usepackage{authblk}
\usepackage{hyperref}
\usepackage{xcolor}

%\usepackage{pythonhighlight}

\usepackage[utf8]{inputenc}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10} % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

\newcommand\terminalstyle{\lstset{
basicstyle=\ttm,
frame=none,             % Any extra options here
aboveskip=20pt,
belowskip=20pt,
xleftmargin=0.5cm,
}}
\lstnewenvironment{terminal}[1][]
{
\terminalstyle
\lstset{#1}
}
{}


% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
morekeywords={self},       % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},     % Custom highlighting
emphstyle=\ttb\color{deepred},  % Custom highlighting style
stringstyle=\color{deepgreen},
frame=none,             % Any extra options here
showstringspaces=false,
numbers=none,
numbersep=5pt,
aboveskip=20pt,
belowskip=20pt,
xleftmargin=0.5cm,
}}

% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


\usepackage{natbib}
\setcitestyle{aysep={}} 

\usepackage{lipsum} 

\hypersetup{
  colorlinks,
  linkcolor={red!50!black},
  citecolor={blue!50!black},
  urlcolor={blue!80!black}
}

\author{Joseph D. Hughes}
\affil{U.S. Geological Survey, Model Support and Maintence Branch, 927 W Belle Plaine Ave, Chicago, IL, USA}
\author{Christian D. Langevin}
\affil{U.S. Geological Survey, Model Support and Maintence Branch, 2280 Woodale Dr, Mounds View, MN, USA}
\author{Scott R. Paulinski}
\affil{U.S. Geological Survey, California Water Science Center, 4165 Spruance Road, Suite 200, San Diego, CA, USA}
\author{Joshua D. Larsen}
\affil{U.S. Geological Survey, California Water Science Center, 6000 J Street, Placer Hall, Sacramento, CA, USA}
\author{David Brakenhoff}
\affil{Artesia Water, Korte Weistraat 12, Schoonhoven, Netherlands}


\begin{document}

\onecolumn

\title{Modern and Reproducible Groundwater Modeling Workflows with FloPy} 

\maketitle


\begin{abstract}

\noindent FloPy functionality has been expanded from the capabilities described in \cite{bakker2016scripting} to support the latest version of MODFLOW (MODFLOW 6). FloPy classes are automatically generated using the same files used to generate the MODFLOW 6 input guide, which allows new features to be supported immediately and FloPy to be a critical component for MODFLOW 6 development and testing. FloPy can be used to download MODFLOW-based and other executables for Linux, MacOS, and Windows operatings systems, which simplifies the process required to download and use these executables. Expanded FloPy capabilities include (1) full support for structured (DIS), layer-based unstructured (DISV), and fully-unstructured (DISU) MODFLOW 6 discretization types; (2) geoprocessing of shapefile-like and raster data to develop model data for all MODFLOW 6 discretization types; (3) the addition of functionality to provide user-centric access to simulated output data; (4) extension of plotting capabilities to unstructured MODFLOW 6 discretization types; and (5) the ability to export model, package, and individual array data to shapefiles, NetCDF, and VTK formats for processing, analysis, and visualization by other software products. Examples of using expanded FloPy capabilities are presented for a hypothetical watershed. An unstructured groundwater flow and transport model, with several advanced stress packages, is presented to demonstrate how FloPy can be used to develop complicated model datasets from original source data (shapefiles and rasters), post-process model results, and plot simulated results.

\end{abstract}

\section{Introduction}

FloPy is a popular Python package for constructing, running, and post processing MODFLOW-based groundwater flow and transport models \citep{bakker2016scripting}. It is an open-source Python package and continues to be developed with input from a growing community of modelers. Making use of open-source languages (such as R and Python) to write scripts and to use version control (such as Git) allows us to share our codes for inspection and use by the hydrological community. It has been recommended as one way to facilitate repeatable research and sharing of ideas \citep{fienen2016}. \cite{bakker2016scripting} describe the general approach for working with models within the python environment and emphasize the reproducible nature of developing models through scripting.

Python is an interpreted, object-oriented programming language that has gained widespread popularity in science and engineering \citep{perez2010python}. Python is a high-level programming language, which means it has a more powerful syntax and a more complete set of data structures than low-level languages (Fortran or C, for example). In a high-level language, complex tasks can be achieved with a few lines of readable code. In addition to the core Python language, there is an extensive library of Python packages for just about any type of scientific analysis. Robust libraries are available for working with arrays \citep[Numpy;][]{2020NumPy-Array}, making publication-quality graphics \citep[Matplotlib;][]{hunter2007matplotlib}, optimization and statistics \cite[Scipy;][]{2020SciPy-NMeth}, working with geospatial information (Fiona; \citealp{fiona-gillies}, Shapely; \citealp{shapely-gillies}), and performing data analysis \citep[Pandas;][]{mckinney2011pandas}. These packages, together with the interactive IPython environment \citep{perez2007ipython} and Jupyter Notebooks \citep{Kluyver:2016aa}, form the core of what is called the Scipy Stack and are at the heart of exploratory computing with Python. Python itself, the Scipy Stack, and a long list of other packages are open-source software, and can be downloaded and used for free.

FloPy is used to pioneer new methods and analysis tools, such as deep learning approaches for improving groundwater model calibration \citep{sun2018, zhou2021}, regionalization of residence times using metamodeling \citep{starn2018}, iterative ensemble approaches for calibration and uncertainty quantification \citep{white2018ies}, and exploration of alternative parameterization schemes for risk analysis \citep{knowling2019}. There are numerous examples of constructing MODFLOW models to solve applied groundwater problems \citep{befus2017, vanengelen2018, ebeling2019, zipper2019, befus2020}. Used in GIS-based tools, such as FREEWAT \citep{freewat2018} and other cyberinfrastructures \citep{essawy2018} to export models into MODFLOW datasets. FloPy can also be used as the ``glue'' to help couple MODFLOW to other hydrological models \citep{burek2020} or even to agent-based models designed to quantify the effects of decision makers on environmental behavior \citep{jaxarozen2019}. 

We use FloPy extensively to teach MODFLOW and groundwater modeling to early- and mid-career engineers and scientists. Other organizations also use FloPy to teach MODFLOW (for example, Hatari Labs and the Australian Water School). Annotated Jupyter notebooks and example scripts are very useful for demonstrating concepts and provide a resource that can be used as templates for developing real-world model applications. We routinely rely on FloPy to load and debug user's model applications and with the initial release of MODFLOW 6 groundwater flow model \citep{modflow6gwf} we started to rely on FloPy for MODFLOW development. We write tests that rely on FloPy to construct and run models, and then read output. We then verify that the output is as expected, by using analytical solutions, other models, or results that have been confirmed to be correct.

The purpose of this paper is to highlight important FloPy advances since it was first described by \cite{bakker2016scripting}, provide examples that demonstrate these new capabilities, and reinforce the advantages of the modern scripting workflow for developing reproducible groundwater flow and transport models that can be easily updated as new data become available. The important advances described here include (1) complete support for all models, packages, and options implemented in the core version of MODFLOW supported by the U.S. Geological Survey (MODFLOW 6); (2) generalized support for models based on a regular grid consisting of layers, rows, and columns, and also for models based on unstructured grids; (3) implementation of new geoprocessing capabilities to rapidly populate models with data from a variety of input sources; (4) simplified access to model results; (5) plotting capabilities for map and cross-section views of model data; and (6) export capabilities for writing model data to a variety of output formats.


\section{FloPy Support for MODFLOW 6}

The most recent version of MODFLOW (MODFLOW 6) is an object-oriented program and framework developed to provide a platform for supporting multiple models and multiple types of models within the same simulation \citep{modflow6gwf, modflow6framework, morway2021use}. These models can be independent of one another with no interaction, they can exchange coefficients and dependent variables (for example, head), or they can be tightly coupled at the matrix level by adding them to the same numerical solution. Transfer of information between models is isolated to exchange objects, which allow models to be developed and used independently. Within this new framework, a regional-scale groundwater model may be coupled with multiple local-scale groundwater models. 

MODFLOW 6 currently includes the Groundwater Flow (GWF) Model and the Groundwater Transport (GWT) Model each with packages to represent surface water processes, groundwater extraction, external boundaries, mass sources and sinks, and mass sorption and reactions. GWF and GWT models can be developed using regular model grids consisting of layers, rows, and columns or they can be developed using more general unstructured grids using many of the concepts and numerical approaches available in MODFLOW-USG \citep{modflowusg}. MODFLOW 6 also includes advanced formulations to simulate three-dimensional anisotropy and dispersion \citep{modflow6xt3d}, coupled variable-density groundwater flow and transport \citep{langevin2020hydraulic}, and a water mover package to represent natural and managed hydrologic connections \citep{morway2021use}.

Development and testing of the MODFLOW 6 program relies heavily on tight integration with FloPy. A key component of this tight integration is the capability to quickly support new MODFLOW 6 models and packages with FloPy. Unlike the FloPy support for previous MODFLOW versions (for example, MODFLOW-2005, MODFLOW-NWT, MODFLOW-USG, and SEAWAT), the FloPy python classes for MODFLOW 6 are dynamically generated from simple text files that describe the input file structure (Figure~\ref{fig:mf6definition}). This allows MODFLOW 6 developers to write tests for new models, packages, and functionality as they are developed. All MODFLOW 6 model input files are described using ``definition files.'' These definition files are used to generate the user input and output guide. These same definition files are also used to generate FloPy classes, with argument docstrings corresponding to input variable descriptions in the input and output guide. Definition files used to create FloPy python classes for MODFLOW 6 are located in the \texttt{flopy/mf6/data/dfn/} subdirectory in the \texttt{site-packages} directory for your Python distribution or Python environment. The FloPy python classes for MODFLOW 6 can be regenerated using 

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/mf6definition.pdf}
	\end{center}
	\caption{Relation between MODFLOW 6 input description files and the MODFLOW 6 input and output guide and the FloPy Python classes for MODFLOW 6.}
	\label{fig:mf6definition}
\end{figure}

\begin{python}
>>> import flopy
>>> flopy.mf6.utils.createpackages.create_packages()
\end{python}

\noindent New functionality can be added by users to existing packages by modifying existing definition files using instructions provided in the \href{https://github.com/MODFLOW-USGS/modflow6/tree/develop/doc/mf6io/mf6ivar}{MODFLOW 6 GitHub repository}. The existing definition files can also be used as a template for creating classes for new MODFLOW 6 models or packages. New definition files should be placed in the \texttt{flopy/mf6/data/dfn/} subdirectory prior to rerunning \pythoninline{flopy.mf6.utils.createpackages.create_packages()}.

\section{Common Modeling Tasks}

\subsection{Getting MODFLOW-based and Other Executables}

FloPy for MODFLOW 6 relies on a number of helper classes, which wrap functionality available in pre-compiled external executables, to generate unstructured models and calculate water budgets on user-defined zones. To facilitate getting these executables and other MODFLOW and related programs (for example, MODPATH, MT3DMS, MT3D-USGS, SEAWAT, etc.) can be installed using

\begin{terminal}
get-modflow :flopy
\end{terminal}

\noindent in a terminal or at the command line after installing FloPy. The \texttt{get-modflow} command downloads the latest release of MODFLOW and related programs for the operating system the command is run on (Windows, MacOS, or Linux) from a \href{https://github.com/MODFLOW-USGS/executables}{Executables GitHub repository}. \texttt{get-modflow} can also download previous versions of MODFLOW 6 and the latest development version of MODFLOW 6 using instructions available on the \href{https://github.com/modflowpy/flopy/blob/develop/docs/get_modflow.md}{FloPy GitHub repository}.

\subsection{Managing and Creating Model Grids}

FloPy was originally developed to support models that are based on a regular grid consisting of layers, rows, and columns. With recent support for unstructured grids in MODFLOW \citep{modflowusg, modflow6gwf} it became necessary to revise the underlying approach for managing spatial discretization information in FloPy. The goal was to containerize grid information into a single location and use this information throughout FloPy modeling tasks for geospatial processing, plotting, and exporting. Spatial discretization is now handled in FloPy through dedicated model grid classes. There is a \texttt{Grid} class, which serves as the base class for the \texttt{StructuredGrid}, \texttt{VertexGrid}, and \texttt{UnstructuredGrid} classes. Grid objects can be created by the user for preprocessing, and they will be automatically generated and attached to a FloPy model object.

Regular MODFLOW grids can have constant row and column spacings, as shown in Figure \ref{fig:grids}A, or they can have variable row and column spacings to focus resolution around an area of interest, as shown in Figure \ref{fig:grids}B. The following Python code shows how to create a \texttt{StructuredGrid} object in FloPy. A \texttt{StructuredGrid} object will also be created from discretization data required when instantiating a MODFLOW 6 \texttt{DIS} object using \texttt{flopy.mf6.ModflowGwfdis()}. 

\begin{python}
>>> regular_grid = flopy.discretization.StructuredGrid(nlay=nlay, 
... delr=delr, delc=delc, xoff=0.0, yoff=0.0, angrot=0.0, top=top, botm=botm)
\end{python}


\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/grids_geoprocessing.png}
	\end{center}
	\caption{Examples of grids that can be generated and processed using FloPy for a hypothetical watershed, including (A) a regular MODFLOW grid with constant and equal row and column spacings, (B) a regular MODFLOW grid with variable row and column spacings, (C) a regular MODFLOW child grid nested within a regular MODFLOW parent grid, (D) a quadtree grid generated with the GRIDGEN program \citep{gridgen} through the FloPy wrapper, (D) a triangular grid generated with the Triangle program \citep{trianglemesh} through the FloPy wrapper, and (E) a Voronoi grid created from the triangular mesh.}\label{fig:grids}
\end{figure}


MODFLOW 6 was developed to natively support multi-model simulations \citep{modflow6framework}. One form of multi-model simulation is a nested grid application in which a more finely discretized child model is embedded within a more coarsely discretized parent model \citep{modflowlgr, vilhelmsen2012evaluation, modflowlgr2}. The use of a locally refined grid (LGR) within a parent grid offers computation benefits in that the additional refinement is targeted to an area of interest. FloPy provides a utility class, called \texttt{Lgr()} for constructing the data required to tightly couple parent and child models within a single MODFLOW 6 simulation.  Figure \ref{fig:grids}C shows two \texttt{StructuredGrid} objects---one object represents the parent model grid and the other represents the nested child grid. The \texttt{Lgr()} class defines the connection properties between cells in the parent model and cells in the child model. The utility is general in that the child model can have more layers than the parent model.

FloPy supports management and generation of unstructured grids. Unstructured grids are represented in FloPy as being layered or fully unstructured. A layered grid is one in which the same grid applies to all model layers. An unstructured grid is more general and allows the model grid to change with depth. Layered grids and unstructured grids are stored in FloPy as \texttt{VertexGrid} and \texttt{UnstructuredGrid} objects, respectively.

A layered quadtree grid can be created with FloPy using the \texttt{Gridgen()} utility class, which is a wrapper around the GRIDGEN program \citep{gridgen}. GRIDGEN starts with a regular MODFLOW grid provided by the user. The program then recursively subdivides individual cells that intersect with refinement features into quarters until a maximum level of refinement is met. Refinement features may be points, lines, or polygons. Smoothing is automatically handled so that a cell is connected to no more than two cells in any primary horizontal direction and four cells in the vertical direction.  Figure \ref{fig:grids}D shows an example of a quadtree grid created with GRIDGEN in which a base grid is refined along streams. The following Python code shows the steps for creating the quadtree grid with GRIDGEN.

\begin{python}
>>> sim = flopy.mf6.MFSimulation()
>>> gwf = flopy.mf6.ModflowGwf(sim)
>>> dis6 = flopy.mf6.ModflowGwfdis(gwf, nrow=nrow, ncol=ncol, delr=dy, delc=dx)
>>> g = Gridgen(dis6, model_ws=temp_path)
>>> g.add_refinement_features([[closed_polygon]], "polygon", 0, range(1))
>>> g.add_refinement_features(stream_points, "line", 2, range(1))
>>> g.build(verbose=False)
>>> gridprops_vg = g.get_gridprops_vertexgrid()
>>> quadtree_grid = flopy.discretization.VertexGrid(**gridprops_vg)
\end{python}

FloPy also provides a wrapper utility for the Triangle mesh generation program \citep{trianglemesh}. The FloPy (\texttt{Triangle()}) utility class writes the Triangle program input file, runs the Triangle program, and then loads the triangular mesh. Users provide the maximum area for individual triangles, angle constraints, a polygon describing the model domain, and so forth. Figure \ref{fig:grids}E shows an example of a triangular grid created with the Triangle program. The Python code for creating the triangular grid is shown below.

\begin{python}
>>> tri = flopy.utils.triangle.Triangle(maximum_area=maximum_area, 
... angle=30, nodes=nodes, model_ws=temp_path)
...
>>> tri.add_polygon(boundary_points)
>>> tri.build(verbose=False)
>>> cell2d = tri.get_cell2d()
>>> vertices = tri.get_vertices()
>>> triangular_grid = VertexGrid(vertices=vertices, cell2d=cell2d, 
... idomain=idomain, nlay=nlay, ncpl=tri.ncpl, top=top, botm=botm)
...
\end{python}

A triangular grid can be converted into a Voronoi grid using the \texttt{VoronoiGrid()} utility class within FloPy. This utility class uses SciPy routines \citep{2020SciPy-NMeth} to construct Voronoi polygons around each vertex in the triangular mesh. Figure \ref{fig:grids}F shows an example of a Voronoi grid created from the triangular mesh shown in Figure \ref{fig:grids}D. The steps for creating the Voronoi grid from the Triangle object are shown below.

\begin{python}
>>> vor = flopy.utils.voronoi.VoronoiGrid(tri)
>>> gridprops = vor.get_gridprops_vertexgrid()
>>> voronoi_grid = VertexGrid(**gridprops, nlay=nlay, idomain=idomain)
\end{python}

\texttt{StructuredGrid}, \texttt{VertexGrid}, and \texttt{UnstructuredGrid} grid objects have useful properties (\texttt{.property}) and methods (\texttt{.method()}) for accessing or mapping locations on the model grid including: (1) conversion of xy pairs from local to global coordinates (\texttt{.get\_coords()}) and from global to local coordinates (\texttt{.get\_local\_coords()}); (2) getting x, y, and z coordinates for cell centers (\texttt{.xcellcenters}, \texttt{.ycellcenters}, \texttt{.zcellcenters}, and \texttt{.xyzcellcenters}) and vertices (\texttt{.xvertices}, \texttt{.yvertices}, \texttt{.zvertices}, and \texttt{.xyzvertices}); (3) intersecting a list of xy pairs with the grid and returning the appropriate \texttt{cellid} (\texttt{.intersect()}). Other interesting grid object properties and methods include generating a grid object from a MODFLOW 6 binary grid file (\texttt{.from\_binary\_grid\_file()}), calculating the cell thickness for each cell (\texttt{.thick}), and the saturated thickness for each cell (\texttt{.saturated\_thick}).

The ability to develop model grid types using FloPy allows for innovation in the way a study area is discretized in order to tailor the grid to the needs of the study. For example, \cite{Moussa2018} used a Voronoi grid to add additional resolution in the vicinity of irrigation wells in the Frenchman Creek Basin in Nebraska, USA to quantify the effects of land-use change and irrigation on streamflow depletion. Furthermore, the ability to develop multi-model simulations using FloPy allows higher-resolution inset models to be added in focused areas. \cite{fienen2022simulation} used focused inset models implicitly coupled to a coarse regional model and solved as a single system of equations to better represent lakes and quantify lake/groundwater interactions in the Central Sands region in Wisconsin, USA. Inset models of lakes in \cite{fienen2022simulation} were developed using \texttt{modflow-setup} \citep{leaf2022modflow}, which relies on FloPy functionality to generate MODFLOW 6 datasets.

\subsection{Geospatial Processing}

Geospatial processing is often a fundamental part of creating a groundwater model. New geospatial processing functionality has been added to FloPy to help users construct models using data from common input sources. The geospatial processing functionality has been implemented to work with the different types of model grids so that it is straightforward to build and construct models with different grid resolutions or grid types. The geospatial processing routines work with all three of the model grid types (\texttt{StructuredGrid}, \texttt{VertexGrid}, and \texttt{UnstructuredGrid}). 

A common geospatial processing task is resampling of raster data onto a model grid. For example, it is often necessary as part of model construction to resample a raster data set of land surface elevation onto a model grid. FloPy includes a new raster sampling utility based on the Rasterio Python package \citep{gillies_2019}. The following Python code demonstrates the steps for resampling an Esri ASCII raster format grid onto a Voronoi grid.

\begin{python}
>>> fine_topo = flopy.utils.Raster.load("./grid_data/fine_topo.asc")
>>> top_vg = fine_topo.resample_to_grid(voronoi_grid, band=fine_topo.bands[0],
... method="linear", extrapolate_edges=True)
...
\end{python}

\noindent The result of raster resampling is a numpy array, equal in size to the number of cells in the Voronoi grid, with an interpolated land surface elevation for each model cell. In this Python code example, the land surface grid was interpolated to the Voronoi grid using a ``linear'' method, however, the method also supports other options (nearest, cubic, mean, median, min, and max) for resampling. The color floods of elevation in Figure \ref{fig:grids} show the results of linear raster resampling for land surface onto a variety of structured and unstructured model grids.

Performing intersections of hydrologic features with the model grid is another common modeling task. FloPy is now equipped with robust and efficient capabilities for intersecting a model grid with points, lines, and polygons. The underlying intersection routines rely on the Shapely Python package \citep{shapely-gillies} to determine intersection properties. When a point or collection of points is intersected with a model grid, the grid intersection routine returns the cells that intersect with the points. When a line or collection of lines is intersected with a model grid, the grid intersection routine returns the cells that intersect with the lines and the lengths of lines within the cell. The line and grid intersection routine also creates and returns individual line segments of the line features within each intersected cell. When a polygon or collection of polygons is intersected with a model grid, the grid intersection routine returns the cells that intersect with the polygons and the polygon area within the cell. The polygon and grid intersection routine also creates and returns individual polygons of the original polygon features within the intersected cells.

The following Python code demonstrates the steps for identifying the grid cells that intersect with a collection of line segments.

% something seems funky with this code example. The grid intersect routine should be able to do this all in one step.
\begin{python}
>>> ixs = flopy.utils.GridIntersect(voronoi_grid, method="vertex")
>>> cellids = []
>>> for points in segments:
...   segment = ixs.intersect(LineString(points), sort_by_cellid=True)
...   cellids += segment["cellids"].tolist()
...
\end{python}

\noindent The result of this code snippet is a list of Voronoi grid cell numbers (called ``cellids'') that intersect with the model grid.  The \texttt{ixs.intersect()} method also returns the \texttt{"lengths"} of the shapelike collection intersecting each cell, the \texttt{"vertices"} corresponding to each cell that intersects a collection of shapelike objects, and a shapely object (\texttt{"ixshape"}) each portion of the original shapelike collection that intersects a cell. Results of the grid intersection for a linear stream network and the six different model grids is shown in Figure \ref{fig:intersections}.

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/grids_intersection.png}
	\end{center}
	\caption{Examples of the intersection of a linear stream network with the model grids shown in Figure~\ref{fig:grids}. Intersections were performed using FloPy for (A) a regular MODFLOW grid, (B) a regular MODFLOW grid with variable row and column spacing, (C) a regular MODFLOW child grid nested within a regular MODFLOW parent grid, (D) a quadtree grid, (D) a triangular grid, and (E) a Voronoi grid. Shaded cells represent those cells that intersect with the linear stream network. Individual plots in this figure are centered on the location of the child grid shown in Figure~\ref{fig:grids}C.}
	\label{fig:intersections}
\end{figure}


\subsection{Processing MODFLOW 6 output}

MODFLOW 6 has many different types of output that can be created during a simulation. A GWF Model, for example, can write simulated heads and detailed budget information to binary files. Global model budgets can be written to comma-separated value text files. Some individual GWF and GWT Model advanced stress packages can also write simulated output during a simulation. For example, the Lake (LAK) Package can write simulated lake stages and detailed lake budget information to binary files. Likewise, the Multi-Aquifer Well (MAW) Package can write simulated well head and well budgets to binary files. Recent improvements have been made to FloPy to allows users easier access to simulation results using \texttt{.output} routines. Prior to these improvements, users were required to instantiate head, concentration, and budget file readers using file paths and names in order to access this information. With the \texttt{.output} routines, the readers are automatically generated when called by the user.

The following \texttt{.methods()} syntax shows how a user can discover the type of output information that is available for the specified \texttt{gwf} model.

% not sure where there is a list() object here.
\begin{python}
>>> gwf.output.methods()
['list()', 'zonebudget()', 'budget()', 'budgetcsv()', 'head()']
\end{python}

\noindent The \texttt{.list()} method can be used to get the incremental (\texttt{incremental=True}) or cumulative budget information for the \texttt{gwf} model for a user-specified simulation time, zero-based time step--stress period tuple, or zero-based index. The \texttt{.zonebudget{}} method allows the user to easily build a ZoneBudget6 instance, then run the model, and view output. The \texttt{.budget()} method gives user access to data in binary MODFLOW 6 cell-by-cell budget files. The The \texttt{.budgetcsv()} method gives user access to cumulative and incremental global budget data saved to a comma separated values file. The \texttt{.head()} method gives user access to data in the binary MODFLOW 6 head file.

Similarly, The following \texttt{.methods()} syntax shows how a user can discover the type of output information that is available for advanced stress packages like the LAK package.

\begin{python}
>>> gwf.lak.output.methods()
['zonebudget()', 'budget()', 'budgetcsv()', 'package_convergence()', 'obs()',  'stage()']
\end{python}

\noindent The \texttt{.package\_convergence()} method can be used to get the convergence information for an advanced stress package. The \texttt{.obs()} method can be used to get observation data saved for a model or stress package as a numpy record array or pandas data frame. The \texttt{.stage()} method is the dependent variable for the LAK package and is equivalent to the \texttt{.head()} method for the \texttt{gwf} model. 

\subsubsection{Processing simulated dependent-variable data}

Dependent-variable data (for example, head, stage, or concentration) for a MODFLOW 6 groundwater flow or transport model can be accessed using the \texttt{.output()} method on the GWF or GWT model, respectively. To access the simulated head output, for example, a call can be made to the head reader to retrieve data for a specified simulation time using the \texttt{.get\_data()} method as follows.

\begin{python}
>>> head = gwf.output.head().get_data(totim=1.0)
\end{python}

\noindent In this case, the \texttt{head} variable is a numpy array equal in size to the size of the model grid. Head data can also be accessed for a zero-based time step--stress period tuple 

\begin{python}
>>> head = gwf.output.head().get_data(kstpkper=(0,0))
\end{python}

\noindent or a zero-based index

\begin{python}
>>> head = gwf.output.head().get_data(idx=0)
\end{python}

\noindent in addition providing a user-specified simulation time (\texttt{totim=}). 

\subsubsection{Processing simulated cell-by-cell budget results}

Similar to head output cell-by-cell budget information can be accessed using FloPy. Unlike the simulated head file, the cell-by-cell budget file can have data for more than one item, which can be either arrays or lists of data. The data in the cell-by-cell budget file can be determined using

\begin{python}
>>> gwf.output.budget().list_unique_records()
RECORD           IMETH
----------------------
FLOW-JA-FACE         1
DATA-SPDIS           6
DATA-SAT             6
WEL                  6
DRN                  6
RCHA                 6
EVTA                 6
SFR                  6
LAK                  6
\end{python}

\noindent The \texttt{IMETH} defines if the data is an array (\texttt{IMETH=1}) or is list based (\texttt{IMETH=6}). Cell-by-cell specific-discharge data can be extracted using

\begin{python}
>>> spdis = gwf.output.budget().get_data(totim=1.0, text="DATA-SPDIS")[0]
\end{python}

\noindent Specific-discharge data is returned as a list containing a Numpy record array for the user-specified simulation time (\texttt{totim=}). Like MODFLOW head data, all of the data in the cell-by-cell data file for a user-specified simulation time (\texttt{totim=}), zero-based time step--stress period tuple (\texttt{kstpkper=}), or zero-based index (\texttt{idx=}) can also be extracted. Specific-discharge data can be processed into a form that can be plotted with FloPy using 

\begin{python}
>>> qx, qy, qz = flopy.utils.postprocessing.get_specific_discharge(spdis, gwf, 
... head=head)
\end{python}

\noindent The optional argument \texttt{head=} above sets the specific-discharge in inactive or dry cells to NaN. The \texttt{get\_specific\_discharge()} method also includes functionality to plot specific discharge values at the cell \texttt{"centers"} (default), \texttt{"faces"}, or \texttt{"vertices"}. 

\subsubsection{Performing zone budgets analyses}

\texttt{zonebudget()} output methods are available for both the \texttt{gwf} model and the \texttt{gwf.lak} advanced stress package examples shown above since they both solve a continuity equation. The \texttt{zonebudget()} output method can be used to perform a Zone Budget analysis on the LAK advanced stress package using

\begin{python}
>>> zonbud = gwf.lak.output.zonebudget(zarr)
>>> zonbud.write_input()
>>> zonbud.run_model()
FloPy is using the following executable to run the model: zbud6
                    ZONEBUDGET Version 6
                   U.S. GEOLOGICAL SURVEY
                  VERSION 6.3.0 03/04/2022
.......................................................................
Normal Termination
(True, [])
\end{python}

\noindent \texttt{zarr} in the \texttt{gwf.lak.output.zonebudget()} is a numpy array that defines an integer zone for each lake in the LAK advanced stress package. Zone Budget output can be returned as a numpy record array (\texttt{.get\_budget()} or \texttt{get\_volumetric\_budget()}) or a panda dataframe (\texttt{get\_dataframes()}).

\subsection{Plotting} \label{sec:plotting}

FloPy plotting functions presented in \cite{bakker2016scripting} have been updated to support plotting both structured and unstructured models in map and cross-section view using the \texttt{.PlotMapView()} and \texttt{.PlotCrossSection()} classes, respectively. The plotting methods are thin wrappers around matplotlib plotting methods and allow fine-grained control using matplotlib keyword arguments (\texttt{kwargs}). The following Python code demonstrates the steps for plotting a map of simulated heads, the model grid, the location of drain (DRN) package cells, specific-discharge vectors, and head contours for the \texttt{gwf} model.

\begin{python}
>>> mm = flopy.plot.PlotMapView(model=gwf)
>>> mm.plot_array(head, edgecolor="0.5")
>>> mm.plot_bc("DRN")
>>> mm.plot_grid()
>>> cs = mm.contour_array(head)
>>> mm.ax.clabel(cs)
>>> mm.plot_vector(qx, qy, normalize=True)
>>> plt.show()
\end{python}

\noindent Figure~\ref{fig:flopyplots}\textit{A} shows the outcome of the python code demonstrated above with additional geographic features and fine-grained control of grid lines, text, annotations, tick locations, and axis labels. Results shown in Figure~\ref{fig:flopyplots} are for a steady-state model discretized into convertible three layers, isotropic hydraulic properties, a hydraulic conductivity of 1 m/d, rivers represented a drain cells, and drains located on the top of the model in layer 1 to prevent groundwater levels from exceeding the top of the model, and an areal recharge rate of 0.000001 m/d. Figure~\ref{fig:flopyplots}\textit{B} shows used of the \texttt{.plot\_array()} method to show a map of the layer containing the water table, drain cells where the groundwater is discharging to a river, and cells where groundwater is discharging to the surface.

The following Python code demonstrates the steps for plotting a cross-section of simulated heads and the model grid for the \texttt{gwf} model along an arbitrary line using a list of xy tuples defining the vertices of the line. For structured grids, cross-sections can also be specified along a row or column.

\begin{python}
>>> fx = flopy.plot.PlotCrossSection(model=gwf, 
... line={"line": [(0, 42500), (186801, 42500)]})
...
>>> fx.plot_array(head, head=head)
>>> fx.plot_grid()
>>> plt.show()
\end{python}

\noindent The \texttt{head=} keyword option \texttt{plot\_array()} method in the python code demonstrated above limits the color flood to the saturated thickness of water in each cell. Figure~\ref{fig:flopyplots}\textit{C} and \textit{D} show the outcome of the python code demonstrated along cross-section lines A--A' and B--B' (shown in Figure~\ref{fig:flopyplots}\textit{A}) above with fine-grained control of grid lines, text, annotations, tick locations, and axis labels. Note that the color flood of head in Figure~\ref{fig:flopyplots}\textit{C} and \textit{D} shows that unconfined conditions occur in higher elevation cells or cells adjacent to river cells.

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/grids_flopy_plots.png}
	\end{center}
	\caption{Examples of FloPy map and cross-section plotting capabilities for a model discretized using a Voronoi grid (Figure~\ref{fig:grids}\textit{F}). (A) Map showing simulated heads and specific-discharge vectors in the upper-most saturated cells. (B) Map showing the layer containing the water table, the location of cells where the aquifer is discharge to rivers represented as drain cells, and the location of cells where groundwater is discharging to the land surface. (C) East-West cross-section along line A--A', shown on Figure~\ref{fig:flopyplots}\textit{A}, showing the model grid, simulated heads, and cells where water-table conditions exist. (D) North-South cross-section along line B--B', shown on Figure~\ref{fig:flopyplots}\textit{A}, showing the model grid, simulated heads, and cells where water-table conditions exist.}
	\label{fig:flopyplots}
\end{figure}

\subsection{Exporting Grid Data to Other Formats}

Model input and output can be exported in a variety of standard formats using the \texttt{export()} method, which is available for FloPy model objects, package objects, binary dependent-variable (head, concentration, \textit{etc.}), and cell-by-cell output files. Standard output formats that are currently supported include shapefiles \citep{environmental1998esri}, NetCDF files \citep{rew2006netcdf, rew1990netcdf}, and Visualization Tool Kit (VTK) files \citep{schroeder:2006:VTK}. Entire models, packages, individual package arrays, binary dependent-variables (for example heads), or three-dimensional representations of binary cell-by-cell data can be exported. Shapefile and VTK output can be exported for all grid types but NetCDF files can currently only be exported for structured grids. The NetCDF output capability has been used to convert entire models and associated output so that it can be rendered in the GWWebFlow viewer \citep{gswebflow2018}.

The following Python code demonstrates the steps for exporting the  \texttt{gwf} model as a VTK dataset with flat cell tops and bottoms (stair-case representation).

\begin{python}
>>> gwf.export("temp_vtk/vtk_smooth", fmt='vtk', smooth=False,
... vertical_exageration=500.0, pvd=True)
...
\end{python}

\noindent VTK models can also be exported with smooth cell tops and bottoms using elevations interpolated to the cell vertices. Other supported export formats can be created by specifing the file extension to be \texttt{.shp} for shapefiles, \texttt{.nc} for NetCDF files, or if the \texttt{fmt} keyword is \texttt{vtk} (as shown above) for VTK files.  Figure~\ref{fig:flopyvtk} shows stair-case and smooth VTK exports of the model described in Section~\ref{sec:plotting} and rendered with Paraview \citep{ahrens2005paraview}.

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/mf6vtk.pdf}
	\end{center}
	\caption{Two different graphical renderings of the Voronoi model grid: (A) stair-cased representation in which cell have flat tops and bottoms and (B) smooth representation in which elevations for cell vertices are interpolated using cell top and bottom elevations.  Renderings were created using Paraview \citep{ahrens2005paraview} and Visualization Tool Kit \citep{schroeder:2006:VTK} files exported from FloPy.}
	\label{fig:flopyvtk}
\end{figure}

\section{Scripting MODFLOW 6 Model Development Using Python and FloPy}

\cite{hill1998} presented a synthetic test case (Synthetic Valley) of an undeveloped alluvial valley surrounded by low permeability bedrock. The model included Blue Lake and Straight River surface water features (Figure~\ref{fig:mvgrid}\textit{A}). The model presented in \cite{hill1998} was simulated using MODFLOWP \citep{hill1992computer} using a structured grid with a constant 152.4 m grid spacing, three model layers, and 1,000 active cells per layer. The upper two layers represented an unconfined aquifer and the third layer represented a lower aquifer unit that is separated from the overlying aquifer by a confining unit in the northern part of the model domain (Figure~\ref{fig:mvgrid}\textit{A}). The confining unit was not explicitly represented in \cite{hill1998}, instead a quasi-3D approach (low vertical conductance) between layers 2 and 3 was used to represent the confining unit. All pre- and post-processing of Synthetic Valley model data was done using FloPy grid, geospatial processing, MODFLOW 6 processing, and plotting functionality discussed previously.

%\lipsum[12-18]

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/mv_voronoi_river_discretization.png}
	\end{center}
	\caption{Synthetic Valley model used to demonstrate the MODFLOW 6 capabilities of FloPy. (A) Map showing the Voronoi grid used to discretized the model domain and the location of Blue Lake, Straight River, and the areal extent of the confining unit separating the upper and lower aquifer units. (B) Map showing model cells intersecting the northern end of Straight River. (C) Map showing model cells intersecting the southern end of Straight River. The cell centroid and cell numbers in the inset areas at the northern and southern end of Straight River are also shown on (B) and (C).}
	\label{fig:mvgrid}
\end{figure}

\subsection{MODFLOW 6 Model Setup}

To demonstrate that capabilities of FloPy and MODFLOW 6 we discretized the 6,096 m x 3,810 m model domain using a Voronoi grid, with 6,343 active cells per layer, and the discretization by vertices (DISV) package (Figure~\ref{fig:mvgrid}\textit{A}). The model grid developed using the \texttt{Triangle()} and \texttt{VoronoiGrid()} utility classes. The model grid was refined under Blue Lake, using a 750 m buffer around Straight River,  and using a 100 m buffer around pumping wells P1, P2, and P3.

In this example we simulate groundwater flow and transport, as a result, the lower aquifer has been discretized into 3 layers. Confining units have to be explicitly simulated in MODFLOW 6, therefore, a total of six layers are simulated. The bottom of layers 1, 2, 3, and 4 were set to constant values of -1.53, -15.24, -15.55 and -30.48 m, respectively. In areas where the confining unit does not exist, the \texttt{idomain} concept was used to eliminate model layer 3 (\texttt{idomain=-1}) in cells where the confining unit does not exist. In these areas, the bottom of layer 2 was set equal to the bottom of layer 3 (-15.55 m) and \texttt{idomain} was set to -1 (vertical pass through cells). 

The bottom of the model (layer 6) is based on \cite{hill1998} and the bottom of layer 5 was specified to be half the distance between the bottom of layers 4 and 6. The top of the model was developed from topographic contours developed for model that was used as the starting point for \cite{hill1998} \citep{pollock2014percomm}; the top of the model is shown in Figure~\ref{fig:mvmap}\textit{A}. The top of the model and the bottom of layers 6 were resampled from the data used in the structured grid model using the \texttt{.resample\_to\_grid()} method and linear interpolation.  Figure~\ref{fig:mvxsection} shows the vertical discretization along cross-section lines A--A' and B--B', which are shown in Figure~\ref{fig:mvmap}\textit{A}. The groundwater flow and transport models were run for a total of 30 years. The groundwater flow model used a single steady-state time step and groundwater flow results were used to run the transport model with a total of 360 time steps with a constant length of 30.4375 days.

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/mv_voronoi_map.png}
	\end{center}
	\caption{Map showing Synthetic Valley model (A) topography and (B) simulated steady-state heads and specific discharge rates in model layer 1. Cross-section lines A--A' and B--B' shown in Figure~\ref{fig:mvxsection} are also shown on (A).}
	\label{fig:mvmap}
\end{figure}

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/mv_voronoi_xsection.png}
	\end{center}
	\caption{Cross-section of Synthetic Valley model grid and simulated steady-state heads along cross-section line (A) A--A' and (B) B--B'. The simulated Blue Lake steady-state stage (3.46 m) and pumping well P-2 are also shown on (A).}
	\label{fig:mvxsection}
\end{figure}

Hydraulic properties for the model were resampled from the data used in the structured grid model that was used as the starting point for \cite{hill1998} \citep{pollock2014percomm}. The horizontal hydraulic conductivity was discretized into five zones with values of 45.72, 50.29, 60.96, 83.82, and 121.92 m/d; the lowest hydraulic conductivity zone was located south of Blue Lake and the highest hydraulic conductivity zone was located beneath Blue Lake. The vertical hydraulic conductivity in the upper and lower aquifer was specified to be one quarter of the horizontal hydraulic conductivity. The horizontal and vertical hydraulic conductivity in the confining unit was set equal to 9.14$\times10^{-4}$ m/d. The horizontal and vertical hydraulic conductivity  were resampled from the data used in the structured grid model using the \texttt{.resample\_to\_grid()} method and the nearest neighbor algorithm.

For the groundwater transport model the porosity was set to 0.2 in the upper and lower aquifer and 0.4 for cells in the confining unit.  For the transport model, the Total Variation Diminishing scheme was used to simulate advection and a  molecular dispersion coefficient of 0 m$^2$/d, longitudinal dispersivity of 75 m, and transverse dispersivity of 7.5 m was specified.

In \cite{hill1998}, Straight River was simulated as head-dependent river (RIV) package cells and Blue Lake was simulated as a high-hydraulic conductivity feature in model layer 1. We have simulated Straight River using the streamflow routing (SFR) package and Blue Lake using the LAK package. The location of the cells in model layer 1 with SFR or LAK package cells were determined using \texttt{GridIntersect().intersect()} FloPy functionality (Figure~\ref{fig:mvmap}\textit{A}). 

Straight River was discretized into 108 reaches. Cells that intersect the northern and southern end of Straight River are shown in Figures~\ref{fig:mvmap}\textit{B} and \textit{C}. The bed thickness and  width of each SFR reach was specified to be 0.3048 and 3.048 m, respectively. The leakance for each SFR reach was calculated using the bed thickness, reach width, and reach length in each cell and based on a total Straight River conductance of 50,971.72 m$^2$/d. A specified rainfall rate of 0.0025 m/d and a potential evaporation rate of  0.0019 m/d was defined for each Straight River reach.

Blue Lake was simulated as a lake on top of the model grid and only had vertical connections to 1,406 cells in the underlying upper aquifer (model layer 1). A bed leakance of 0.0013 1/d was specified for each cell connected to Blue Lake. A specified rainfall rate of 0.0025 m/d and a potential evaporation rate of 0.0019 m/d was defined for Blue Lake.

Drain (DRN) cells were specified in each cell in model layer 1 that was not connected to Blue Lake to prevent water levels from exceeding the top of the model. The conductance of each DRN cell was based on the horizontal cell area, a thickness of 0.3048 m, and a vertical hydraulic conductivity of 0.03048 m/d. The drainage conductance was scaled from 0 to 100\% of the specified conductance from 1 m below the top of the model to the top of the model, respectively.

Areal specified recharge and potential evapotranspiration rates of 0.0025 and 0.0019 m/d were specified using the recharge (RCH) and evapotranspiration (EVT) packages, respectively. The EVT surface was specified to be the top of the model and the EVT extinction depth was specified to be 1 m.

The location of pumping wells P1, P2, and P3 were determined using \texttt{GridIntersect().intersect()} FloPy functionality (Figure~\ref{fig:mvmap}\textit{A}). Pumping rates of -7,600, -7,600, and -1,900 m$^3$/d were specified for pumping wells P1, P2, and P3, respectively.

Transport was not simulated in the LAK and SFR packages. A specified concentration boundary with a concentration of 1.0 mg/L was specified for Blue Lake concentrations. All other stress packages were assumed to have a concentration of 0 mg/L.

An initial head of 11 m was specified for every cell. An initial stage of 3.44 m was specified for Blue Lake. An initial concentration of 0 mg/L was specified for the transport model.

\subsection{Simulated Results}

Simulated heads and vectors of specific discharge in model layer 1 are shown in Figure~\ref{fig:mvmap}\textit{B}.  Specific discharge is greatest on the east side of Blue Lake and in the vicinity of the three pumping wells and Straight River. Cross-sections showing simulated heads along cross-sections A--A' and B--B' are shown in Figure~\ref{fig:mvxsection}. The cross-sections show that water table conditions occur in most of the model domain except in the vicinity of Blue Lake.

Simulated concentrations at the end of 30-years in all six model layers are shown in Figure~\ref{fig:mvxsection}. Simulated concentrations are highest underneath Blue Lake in model layer 1 and do not vary much in model layers 1 and 2. Simulated concentrations in model layer 3 are limited to the extent of the confining unit because the remaining cells in the layer are defined to be vertical pass through cells (\texttt{idomain=-1}). The lateral extent of concentrations does not vary much south of Blue Lake because of the lack of confinement in these areas.

\begin{figure}[ht!]
	\begin{center}
		\includegraphics{figures/mv_voronoi_map_concentration.png}
	\end{center}
	\caption{Maps showing Synthetic Valley simulated concentrations at the end of 30 years in model layer (A) 1, (B) 2, (C) 3, (D) 4, (E) 5, and (F) 6. The extent of the confining unit in model layer 3 is also shown on (C).}
	\label{fig:mvxsection}
\end{figure}

\section{Summary and Conclusions}
FloPy is a popular Python package for building, running, and post processing groundwater models. It is open source and developed with input from a growing community of modelers. This paper summarizes important new FloPy capabilities that have been added since the package was first described by \citep{bakker2016scripting}. The new capabilities can be summarized as follows.

\begin{itemize}
\item FloPy supports the creation of many different types of groundwater models, including models that use MODFLOW 6, MODFLOW-2005, MODFLOW-NWT, MODFLOW-USG, MT3D, MT3D-USGS, and SEAWAT. FloPy support for MODFLOW 6 is based on an entirely new approach designed to automatically support all MODFLOW 6 models, packages, and options. The underlying FloPy classes for MODFLOW 6 are programmatically generated from the same input definition files that are used to construct the MODFLOW 6 user guide. This correspondence ensures that the FloPy classes are in direct correspondence with MODFLOW 6 input.
\item FloPy has been extended to support unstructured model grids in addition to regular grids defined by layers, rows, and columns. FloPy has several different routines for creating unstructured grids. FloPy has a wrapper routine around the GRIDGEN program \citep{gridgen}, which can be used to create layered quadtree grids. FloPy also has a wrapper around the Triangle program \citep{trianglemesh}, which can be used to create triangular meshes. A triangular mesh can be converted by FloPy into a Voronoi grid. Grid information is stored for each FloPy model created by the user. This model grid object is used systemically throughout FloPy for geospatial operations, plotting, and exporting model information to supported formats.
\item Geospatial intersections of points, lines, and polygons with model grids and raster resampling onto model grids are common steps in model construction. FloPy fully supports these geospatial operations through its grid intersection and raster resampling routines.
\item Access to model output using FloPy has been simplified for MODFLOW 6 models. 
\item Map and cross section plotting
\item Export to shapefiles, VTK, and NetCDF
\end{itemize}

FloPy makes it possible to construct, and reproduce the construction, of a groundwater model from native data in any format that can be accessed using Python. The robust new features in FloPy allow users to quickly try different model grids, different model spatial and temporal resolution, and different model configurations. 

It is often useful to write a Python script to construct a groundwater model from start to finish. The new geospatial processing routines make it possible to change model resolution as part of the model construction script. This allows one to prototype fast running models with coarse resolution and use finer resolution as the model starts to behave as intended. This workflow also allows one to conduct grid convergence studies to ensure that the grid is not the cause of unintended model behavior.

\section*{Acknowledgments}
The authors gratefully acknowledge the efforts of Mark Bakker and Vincent E.A. Post for initially developing FloPy and their continued efforts improving FloPy. Funding for this research was provided by the Enterprise Capacity (EC) project of the U.S. Geological Survey Integrated Water Prediction program.

\section*{Data Availability Statement}
FloPy is an open source software product and we welcome bug reports, code contributions, or improvements to the documentation from the community. The FloPy python package can be installed using \texttt{conda} or \texttt{pip}. The source code, code documentation, tutorials, and examples can be found in the \href{https://github.com/modflowpy/flopy}{FloPy GitHub repository}. The Synthetic Valley example is available as a \href{https://modflow6-examples.readthedocs.io/en/master/examples.html}{MODFLOW 6 example} and the hypothetical watershed grid examples are available on the \href{https://github.com/modflowpy/flopy/tree/develop/examples/mf6_groundwater_paper}{FloPy GitHub repository}.


\bibliographystyle{groundwater}
\bibliography{flopy}

\end{document}
